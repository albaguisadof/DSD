/*
 * This is sample code generated by rpcgen.
 * These are only templates and you can use them
 * as a guideline for developing your own functions.
 */

#include "calculadora.h"

calculadora_res1 *
calculadora_1_svc(calculo1 arg1,  struct svc_req *rqstp)
{
	/*
	Las operaciones simples implementadas son las siguientes:

	+:suma
	-:resta
	x:multiplica
	/:divide
	m:modulo (ej: 4 % 2)
	^:eleva	(ej: 2 ^ 4)
	p:calcula porcentajes (ej: 20 p 34, calcula el 20% de 24)
	r: calcula la raíz cuadrada
		El primer operando es el número deseado para hacer la raíz
		y el segundo operando el número de presición
		ej: 4 r 100
*/

	static calculadora_res1  result;

	xdr_free(xdr_calculadora_res1, &result);

	if(strcmp(arg1.operacion, "+") == 0)
	{
		result.calculadora_res1_u.solucion = arg1.uno + arg1.dos;
	}
	else if(strcmp(arg1.operacion, "-") == 0)
	{
		result.calculadora_res1_u.solucion = arg1.uno - arg1.dos;
	}
	else if(strcmp(arg1.operacion, "x") == 0)
	{
		result.calculadora_res1_u.solucion = arg1.uno * arg1.dos;
	}
	else if(strcmp(arg1.operacion, "/") == 0)
	{
		result.calculadora_res1_u.solucion = arg1.uno / arg1.dos;
	}
	else if(strcmp(arg1.operacion, "m") == 0)
	{
		result.calculadora_res1_u.solucion = (int)arg1.uno % (int)arg1.dos;
	}
	else if(strcmp(arg1.operacion, "^") == 0)
	{
		for(int i = 0; i < arg1.dos -1 ; i++){
			result.calculadora_res1_u.solucion += arg1.uno * arg1.uno;
		}

		if(arg1.dos == 0){
			result.calculadora_res1_u.solucion = 1;
		}
	}
	else if(strcmp(arg1.operacion, "p") == 0)
	{
		result.calculadora_res1_u.solucion = (arg1.uno * arg1.dos)/100.0;
	}
	else if(strcmp(arg1.operacion, "r") == 0)
	{
		float_type raiz = arg1.uno/2;  //Sabemos que la raíz cuadrada se aproxima 
								   		//a la mitad del número
		float_type diferencia = arg1.uno;
		while(diferencia > arg1.dos){
			float_type raiz2 = (raiz + arg1.uno / raiz)/2;
			diferencia =raiz2 - raiz;
			if(diferencia < 0){
				diferencia = - diferencia;
			}
			raiz = raiz2;
		}

		result.calculadora_res1_u.solucion = raiz;
	}

	return &result;
}

calculadora_res2 *
calculadora_2_svc(calculo2 arg1,  struct svc_req *rqstp)
{
	/*
	Las operaciones con vectores de 3 coordenadas realizadas son las siguientes:
	+:suma de vectores
	-:resta de vectores
	x:producto escalar
	v:producto vectorial
	*/
	static calculadora_res2  result;

	xdr_free(xdr_calculadora_res2, &result);

	if(strcmp(arg1.operacion, "+") == 0)
	{
		vector_type vresult;
		vresult.f1 = arg1.uno.f1 + arg1.dos.f1;
		vresult.f2 = arg1.uno.f2 + arg1.dos.f2;
		vresult.f3 = arg1.uno.f3 + arg1.dos.f3;
		result.calculadora_res2_u.solucion = vresult;
	}
	else if(strcmp(arg1.operacion, "-") == 0)
	{
		vector_type vresult;
		vresult.f1 = arg1.uno.f1 - arg1.dos.f1;
		vresult.f2 = arg1.uno.f2 - arg1.dos.f2;
		vresult.f3 = arg1.uno.f3 - arg1.dos.f3;
		result.calculadora_res2_u.solucion = vresult;
	}
	else if(strcmp(arg1.operacion, "x") == 0)
	{
		vector_type vresult;
		vresult.f1 = arg1.uno.f1 * arg1.dos.f1;
		vresult.f2 = arg1.uno.f2 * arg1.dos.f2;
		vresult.f3 = arg1.uno.f3 * arg1.dos.f3;
		result.calculadora_res2_u.solucion = vresult;
	}
	else if(strcmp(arg1.operacion, "v") == 0)
	{
		vector_type vresult;
		vresult.f1 = arg1.uno.f2 * arg1.dos.f3 - arg1.uno.f3 * arg1.dos.f2;
		vresult.f2 = arg1.uno.f3 * arg1.dos.f1 - arg1.uno.f1 * arg1.dos.f3;
		vresult.f3 = arg1.uno.f1 * arg1.dos.f2 - arg1.uno.f2 * arg1.dos.f1;
		result.calculadora_res2_u.solucion = vresult;
	}

	return &result;
}

calculadora_res3 *
calculadora_3_svc(calculo3 arg1,  struct svc_req *rqstp)
{
	/*
	Las operaciones con matrices 3x3 realizadas son las siguientes:
	+:suma de matrices
	-:resta de matrices
	x:producto de matrices
	e:producto escalar de matrices
	*/
	static calculadora_res3  result;

	xdr_free(xdr_calculadora_res3, &result);

	if(strcmp(arg1.operacion, "+") == 0)
	{
		matriz_type mresult;

		mresult.v1.f1 = arg1.uno.v1.f1 + arg1.dos.v1.f1;
		mresult.v1.f2 = arg1.uno.v1.f2 + arg1.dos.v1.f2;
		mresult.v1.f3 = arg1.uno.v1.f3 + arg1.dos.v1.f3;

		mresult.v2.f1 = arg1.uno.v2.f1 + arg1.dos.v2.f1;
		mresult.v2.f2 = arg1.uno.v2.f2 + arg1.dos.v2.f2;
		mresult.v2.f3 = arg1.uno.v2.f3 + arg1.dos.v2.f3;

		mresult.v3.f1 = arg1.uno.v3.f1 + arg1.dos.v3.f1;
		mresult.v3.f2 = arg1.uno.v3.f2 + arg1.dos.v3.f2;
		mresult.v3.f3 = arg1.uno.v3.f3 + arg1.dos.v3.f3;

		result.calculadora_res3_u.solucion = mresult;
	}
	if(strcmp(arg1.operacion, "-") == 0)
	{
		matriz_type mresult;

		mresult.v1.f1 = arg1.uno.v1.f1 - arg1.dos.v1.f1;
		mresult.v1.f2 = arg1.uno.v1.f2 - arg1.dos.v1.f2;
		mresult.v1.f3 = arg1.uno.v1.f3 - arg1.dos.v1.f3;

		mresult.v2.f1 = arg1.uno.v2.f1 - arg1.dos.v2.f1;
		mresult.v2.f2 = arg1.uno.v2.f2 - arg1.dos.v2.f2;
		mresult.v2.f3 = arg1.uno.v2.f3 - arg1.dos.v2.f3;

		mresult.v3.f1 = arg1.uno.v3.f1 - arg1.dos.v3.f1;
		mresult.v3.f2 = arg1.uno.v3.f2 - arg1.dos.v3.f2;
		mresult.v3.f3 = arg1.uno.v3.f3 - arg1.dos.v3.f3;

		result.calculadora_res3_u.solucion = mresult;
	}
	if(strcmp(arg1.operacion, "e") == 0)
	{
		matriz_type mresult;

		mresult.v1.f1 = arg1.uno.v1.f1 * arg1.dos.v1.f1;
		mresult.v1.f2 = arg1.uno.v1.f2 * arg1.dos.v1.f2;
		mresult.v1.f3 = arg1.uno.v1.f3 * arg1.dos.v1.f3;

		mresult.v2.f1 = arg1.uno.v2.f1 * arg1.dos.v2.f1;
		mresult.v2.f2 = arg1.uno.v2.f2 * arg1.dos.v2.f2;
		mresult.v2.f3 = arg1.uno.v2.f3 * arg1.dos.v2.f3;

		mresult.v3.f1 = arg1.uno.v3.f1 * arg1.dos.v3.f1;
		mresult.v3.f2 = arg1.uno.v3.f2 * arg1.dos.v3.f2;
		mresult.v3.f3 = arg1.uno.v3.f3 * arg1.dos.v3.f3;

		result.calculadora_res3_u.solucion = mresult;
	}
	if(strcmp(arg1.operacion, "x") == 0)
	{
		matriz_type mresult;

		mresult.v1.f1 = arg1.uno.v1.f1 * arg1.dos.v1.f1 + arg1.uno.v1.f2 * arg1.dos.v2.f1 
						+ arg1.uno.v1.f3 * arg1.dos.v3.f1;
		mresult.v1.f2 = arg1.uno.v1.f1 * arg1.dos.v1.f2 + arg1.uno.v1.f2 * arg1.dos.v2.f2 
						+ arg1.uno.v1.f3 * arg1.dos.v3.f2;
		mresult.v1.f3 = arg1.uno.v1.f1 * arg1.dos.v1.f3 + arg1.uno.v1.f2 * arg1.dos.v2.f3 
						+ arg1.uno.v1.f3 * arg1.dos.v3.f3;

		mresult.v2.f1 = arg1.uno.v2.f1 * arg1.dos.v1.f1 + arg1.uno.v2.f2 * arg1.dos.v2.f1 
						+ arg1.uno.v2.f3 * arg1.dos.v3.f1;
		mresult.v2.f2 = arg1.uno.v2.f1 * arg1.dos.v1.f2 + arg1.uno.v2.f2 * arg1.dos.v2.f2 
						+ arg1.uno.v2.f3 * arg1.dos.v3.f2;
		mresult.v2.f3 = arg1.uno.v2.f1 * arg1.dos.v1.f3 + arg1.uno.v2.f2 * arg1.dos.v2.f3 
						+ arg1.uno.v2.f3 * arg1.dos.v3.f3;

		mresult.v3.f1 = arg1.uno.v3.f1 * arg1.dos.v1.f1 + arg1.uno.v3.f2 * arg1.dos.v2.f1 
						+ arg1.uno.v3.f3 * arg1.dos.v3.f1;
		mresult.v3.f2 = arg1.uno.v3.f1 * arg1.dos.v1.f2 + arg1.uno.v3.f2 * arg1.dos.v2.f2 
						+ arg1.uno.v3.f3 * arg1.dos.v3.f2;
		mresult.v3.f3 = arg1.uno.v3.f1 * arg1.dos.v1.f3 + arg1.uno.v3.f2 * arg1.dos.v2.f3 
						+ arg1.uno.v3.f3 * arg1.dos.v3.f3;

		result.calculadora_res3_u.solucion = mresult;
	}

	return &result;
}
